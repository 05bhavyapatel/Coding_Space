//Optimal solution
//Time complexity: O(n)
//Space complexity: O(n)

class Solution {
    public int jump(int[] dp, int i, int[] cost){
        if(i >= cost.length){
            return 0;
        }
        if(dp[i] != -1){
            return dp[i];
        }
        int pick = 0, npick = 0;
        pick = jump(dp, i + 1, cost) + cost[i];
        npick = jump(dp, i + 2, cost) + cost[i];
        return dp[i] = Math.min(pick, npick);
    }
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n];
        Arrays.fill(dp, -1);
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i = 2; i < n; i++){
            dp[i] = cost[i] + Math.min(dp[i - 1], dp[i -2]);
        }
        return Math.min(dp[n - 1], dp[n - 2]);
    }
}
